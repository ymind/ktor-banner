package team.yi.kfiglet

import java.io.InputStream
import java.io.InputStreamReader
import java.util.*

/**
 * FigFont represents a FIGlet font that may be used to render text.
 */
open class FigFont {
    open var hardBlankChar = 0.toChar()
        internal set

    open var height = 0
        internal set

    open var baseline = 0
        internal set

    open var maxLength = 0
        internal set

    open var oldLayout = 0
        internal set

    open var commentLines = 0
        internal set

    open lateinit var direction: PrintDirection
        internal set

    open var fullLayout = 0
        internal set

    open var codeTagCount = 0
        internal set

    private var figCharacters: MutableMap<Char, FigCharacter> = HashMap()

    fun getFigCharacter(character: Char): FigCharacter = figCharacters[character]!!

    fun calculateOverlapAmount(char1: Char, char2: Char, smushMode: Int, printDirection: PrintDirection?): Int {
        val layoutOption = LayoutOptions.HORIZONTAL_SMUSHING_BY_DEFAULT or LayoutOptions.HORIZONTAL_FITTING_BY_DEFAULT

        if (!LayoutOptions.isLayoutOptionSelected(layoutOption, smushMode)) return 0
        if (char1 == '\u0000' || char2 == '\u0000') return 0

        val leftFigChar: FigCharacter?
        val rightFigChar: FigCharacter?

        if (printDirection == PrintDirection.LEFT_TO_RIGHT) {
            leftFigChar = getFigCharacter(char1)
            rightFigChar = getFigCharacter(char2)
        } else {
            leftFigChar = getFigCharacter(char2)
            rightFigChar = getFigCharacter(char1)
        }

        if (rightFigChar.width < 2 || leftFigChar.width < 2) return 0

        var smushAmount = rightFigChar.width

        // Calculate the minimum amount that a row of rightFigChar may be smushed into
        // the corresponding row of leftFigChar
        for (row in 0 until height) {
            var rowSmushAmount: Int
            var leftFigCharRightBoundary = leftFigChar.width - 1

            while (leftFigChar.getCharacterAt(leftFigCharRightBoundary, row) == ' ' && leftFigCharRightBoundary > 0) {
                leftFigCharRightBoundary--
            }

            var rightFigCharLeftBoundary = 0

            while (rightFigChar.getCharacterAt(rightFigCharLeftBoundary, row) == ' ' && rightFigCharLeftBoundary < rightFigChar.width - 1) {
                rightFigCharLeftBoundary++
            }

            rowSmushAmount = minOf(rightFigChar.width, leftFigChar.width - (leftFigCharRightBoundary + 1) + rightFigCharLeftBoundary)

            if (leftFigChar.getCharacterAt(leftFigCharRightBoundary, row) == ' ') {
                rowSmushAmount++
            } else if (
                smushem(
                    leftFigChar.getCharacterAt(leftFigCharRightBoundary, row),
                    rightFigChar.getCharacterAt(rightFigCharLeftBoundary, row),
                    smushMode,
                    printDirection,
                ) != '\u0000'
            ) {
                rowSmushAmount++
            }

            smushAmount = minOf(smushAmount, rowSmushAmount)
        }

        return smushAmount
    }

    /**
     * Calculates the character that is the result of merging two characters.
     * Possible outcomes are a single character to use as the replacement for the
     * input characters when smushing FIGcharacters, or the `null`
     * character '/0' which represents unsmushable input characters.
     *
     * @param char1          The first character to smush.
     * @param char2          The second character to smush.
     * @param smushmode      The smushmode that determines how smushing occurs. This value may
     * be generated by combining values from [LayoutOptions].
     * @param printDirection The print direction that determines whether the second character
     * is considered to be to the right or the left of the first.
     * @return The character representing the result of smushing the input
     * characters, or the `null` character '/0' if the input
     * characters cannot be smushed.
     * @see LayoutOptions
     */
    @Suppress("ComplexMethod")
    fun smushem(char1: Char, char2: Char, smushmode: Int, printDirection: PrintDirection?): Char {
        if (char1 == ' ') return char2
        if (char2 == ' ') return char1
        if (!LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_SMUSHING_BY_DEFAULT, smushmode)) return '\u0000'

        if (smushmode and 63 == 0) {
            if (char1 == ' ') return char2
            if (char2 == ' ') return char1
            if (char1 == hardBlankChar) return char2
            if (char2 == hardBlankChar) return char1

            return if (printDirection == PrintDirection.LEFT_TO_RIGHT) char2 else char1
        }

        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_HARDBLANK_SMUSHING, smushmode) && char1 == hardBlankChar && char2 == hardBlankChar) return char1
        if (char1 == hardBlankChar || char2 == hardBlankChar) return '\u0000'
        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_EQUAL_CHARACTER_SMUSHING, smushmode) && char1 == char2) return char1

        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_UNDERSCORE_SMUSHING, smushmode)) {
            if (char1 == '_' && "|/\\[]{}()<>".indexOf(char2) != -1) return char2
            if (char2 == '_' && "|/\\[]{}()<>".indexOf(char1) != -1) return char1
        }

        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_HIERARCHY_SMUSHING, smushmode)) {
            if (char1 == '|' && "/\\[]{}()<>".indexOf(char2) != -1) return char2
            if (char2 == '|' && "/\\[]{}()<>".indexOf(char1) != -1) return char1
            if ("/\\".indexOf(char1) != -1 && "[]{}()<>".indexOf(char2) != -1) return char2
            if ("/\\".indexOf(char2) != -1 && "[]{}()<>".indexOf(char1) != -1) return char1
            if ("[]".indexOf(char1) != -1 && "{}()<>".indexOf(char2) != -1) return char2
            if ("[]".indexOf(char2) != -1 && "{}()<>".indexOf(char1) != -1) return char1
            if ("{}".indexOf(char1) != -1 && "()<>".indexOf(char2) != -1) return char2
            if ("{}".indexOf(char2) != -1 && "()<>".indexOf(char1) != -1) return char1
            if ("()".indexOf(char1) != -1 && "<>".indexOf(char2) != -1) return char2
            if ("()".indexOf(char2) != -1 && "<>".indexOf(char1) != -1) return char1
        }

        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_OPPOSITE_PAIR_SMUSHING, smushmode)) {
            if (char1 == '[' && char2 == ']') return '|'
            if (char2 == '[' && char1 == ']') return '|'
            if (char1 == '{' && char2 == '}') return '|'
            if (char2 == '{' && char1 == '}') return '|'
            if (char1 == '(' && char2 == ')') return '|'
            if (char2 == '(' && char1 == ')') return '|'
        }

        if (LayoutOptions.isLayoutOptionSelected(LayoutOptions.HORIZONTAL_BIG_X_SMUSHING, smushmode)) {
            if (char1 == '/' && char2 == '\\') return '|'
            if (char2 == '/' && char1 == '\\') return 'Y'
            if (char1 == '>' && char2 == '<') return 'X'
        }

        return '\u0000'
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()

        for ((key, value) in figCharacters) {
            stringBuilder.append(key)
            stringBuilder.append(":\n")
            stringBuilder.append(value)
            stringBuilder.append("\n")
        }

        return stringBuilder.toString()
    }

    class Builder : FigFont() {
        override var hardBlankChar = 0.toChar()
        override var height = 0
        override var baseline = 0
        override var maxLength = 0
        override var oldLayout = 0
        override var commentLines = 0
        override var direction: PrintDirection = PrintDirection.LEFT_TO_RIGHT
        override var fullLayout = 0
        override var codeTagCount = 0

        private val characterDataMap: MutableMap<Char, String> = HashMap()

        fun setHardBlankChar(hardBlankChar: Char): Builder {
            this.hardBlankChar = hardBlankChar

            return this
        }

        fun setHeight(height: Int): Builder {
            this.height = height

            return this
        }

        fun setBaseline(baseline: Int): Builder {
            this.baseline = baseline

            return this
        }

        fun setMaxLength(maxLength: Int): Builder {
            this.maxLength = maxLength

            return this
        }

        fun setOldLayout(oldLayout: Int): Builder {
            this.oldLayout = oldLayout

            return this
        }

        fun setCommentLines(commentLines: Int): Builder {
            this.commentLines = commentLines

            return this
        }

        fun setDirection(direction: PrintDirection?): Builder {
            this.direction = direction ?: PrintDirection.LEFT_TO_RIGHT

            return this
        }

        fun setFullLayout(fullLayout: Int): Builder {
            this.fullLayout = fullLayout

            return this
        }

        fun setCodeTagCount(codeTagCount: Int): Builder {
            this.codeTagCount = codeTagCount

            return this
        }

        fun setFigCharacter(character: Char, characterData: String): Builder {
            characterDataMap[character] = characterData

            return this
        }

        fun build(): FigFont {
            val font = FigFont()
            font.hardBlankChar = hardBlankChar
            font.height = height
            font.baseline = baseline
            font.maxLength = maxLength
            font.oldLayout = oldLayout
            font.commentLines = commentLines
            font.direction = direction
            font.fullLayout = fullLayout
            font.codeTagCount = codeTagCount
            font.figCharacters = HashMap(characterDataMap.size)

            for ((key, value) in characterDataMap) {
                font.figCharacters[key] = FigCharacter(font, value)
            }

            return font
        }
    }

    companion object {
        fun loadFigFont(inputStream: InputStream) = InputStreamReader(inputStream).let { FigFontReader(it).readFont() }
    }
}
